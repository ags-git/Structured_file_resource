Передаю модель данных:
CREATE TYPE compliance_status AS ENUM ('non_compliant', 'warning', 'compliant');
CREATE TYPE rule_type AS ENUM ('literal', 'dictionary', 'pattern');

-- Домены данных
CREATE TABLE data_domain (
    data_domain_s INTEGER GENERATED BY DEFAULT AS IDENTITY,
    name VARCHAR(255) NOT NULL,
    description TEXT,
    is_displayed BOOLEAN NOT NULL DEFAULT true,
    key_business_obj_class VARCHAR(255) NOT NULL,
    CONSTRAINT c_data_domain_pk PRIMARY KEY (data_domain_s),
    CONSTRAINT c_data_domain_name_unq UNIQUE (name),
    CONSTRAINT c_data_domain_name_chk CHECK (length(trim(name)) > 0),
    CONSTRAINT c_data_domain_key_obj_chk CHECK (length(trim(key_business_obj_class)) > 0)
);

-- Информационные ресурсы
CREATE TABLE information_resource (
    information_resource_s INTEGER GENERATED BY DEFAULT AS IDENTITY,
    data_domain_s INTEGER NOT NULL,
    path VARCHAR(1024) NOT NULL,
    name VARCHAR(255) NOT NULL,
    scan_schedule VARCHAR(255),
    path_to_mount VARCHAR(255) NOT NULL,
    data_domain_path VARCHAR(100),
    CONSTRAINT c_information_resource_pk PRIMARY KEY (information_resource_s),
    CONSTRAINT c_information_resource_data_domain_fk FOREIGN KEY (data_domain_s) REFERENCES data_domain (data_domain_s) ON DELETE CASCADE,
    CONSTRAINT c_information_resource_path_unq UNIQUE (path),
    CONSTRAINT c_information_resource_path_chk CHECK (path ~ '^//[^/]+/[^/]+'),
    CONSTRAINT c_information_resource_name_chk CHECK (length(trim(name)) > 0),
    CONSTRAINT c_information_resource_mount_chk CHECK (length(trim(path_to_mount)) > 0)
);

-- Пользователи
CREATE TABLE users (
    users_s INTEGER GENERATED BY DEFAULT AS IDENTITY,
    username VARCHAR(255) NOT NULL,
    password_hash VARCHAR(255) NOT NULL,
    email VARCHAR(255),
    CONSTRAINT c_users_pk PRIMARY KEY (users_s),
    CONSTRAINT c_users_username_unq UNIQUE (username),
    CONSTRAINT c_users_username_chk CHECK (length(trim(username)) > 0),
    CONSTRAINT c_users_email_chk CHECK (email ~ '^[A-Za-z0-9._%+-]+@[A-Za-z0-9.-]+\.[A-Za-z]{2,}$')
);

-- Права доступа пользователей к доменам
CREATE TABLE user_domain_access (
    users_s INTEGER,
    data_domain_s INTEGER,
    CONSTRAINT c_user_domain_access_pk PRIMARY KEY (users_s, data_domain_s),
    CONSTRAINT c_user_domain_access_users_fk FOREIGN KEY (users_s) REFERENCES users (users_s) ON DELETE CASCADE,
    CONSTRAINT c_user_domain_access_data_domain_fk FOREIGN KEY (data_domain_s) REFERENCES data_domain (data_domain_s) ON DELETE CASCADE
);

-- Справочники из НСИ
CREATE TABLE dictionary (
    dictionary_s INTEGER GENERATED BY DEFAULT AS IDENTITY,
    code VARCHAR(255) NOT NULL,
    name VARCHAR(255) NOT NULL,
    description TEXT,
    is_actual BOOLEAN NOT NULL DEFAULT true,
    CONSTRAINT c_dictionary_pk PRIMARY KEY (dictionary_s),
    CONSTRAINT c_dictionary_code_unq UNIQUE (code),
    CONSTRAINT c_dictionary_code_chk CHECK (length(trim(code)) > 0),
    CONSTRAINT c_dictionary_name_chk CHECK (length(trim(name)) > 0)
);

-- Значения справочников
CREATE TABLE nsi_data (
    nsi_data_s INTEGER GENERATED BY DEFAULT AS IDENTITY,
    dictionary_s INTEGER NOT NULL,
    entity_id VARCHAR(255) NOT NULL,
    entity_name VARCHAR(255) NOT NULL,
    is_actual BOOLEAN NOT NULL DEFAULT true,
    types JSONB,
    attributes JSONB,
    CONSTRAINT c_nsi_data_pk PRIMARY KEY (nsi_data_s),
    CONSTRAINT c_nsi_data_dictionary_fk FOREIGN KEY (dictionary_s) REFERENCES dictionary (dictionary_s) ON DELETE CASCADE,
    CONSTRAINT c_nsi_data_entity_id_chk CHECK (length(trim(entity_id)) > 0),
    CONSTRAINT c_nsi_data_entity_name_chk CHECK (length(trim(entity_name)) > 0),
    CONSTRAINT c_nsi_data_entity_id_dict_unq UNIQUE (dictionary_s, entity_id)
);

-- Связи между элементами справочников
CREATE TABLE nsi_data_x (
    nsi_data_x_s INTEGER GENERATED BY DEFAULT AS IDENTITY,
    nsi_data_s INTEGER NOT NULL,
    dependent_on INTEGER NOT NULL,
    CONSTRAINT c_nsi_data_x_pk PRIMARY KEY (nsi_data_x_s),
    CONSTRAINT c_nsi_data_x_nsi_data_fk FOREIGN KEY (nsi_data_s) REFERENCES nsi_data (nsi_data_s) ON DELETE CASCADE,
    CONSTRAINT c_nsi_data_x_dependent_fk FOREIGN KEY (dependent_on) REFERENCES nsi_data (nsi_data_s),
    CONSTRAINT c_nsi_data_x_self_ref_chk CHECK (nsi_data_s != dependent_on)
);

-- Уровни эталонной структуры
CREATE TABLE reference_structure_level (
    reference_structure_level_s INTEGER GENERATED BY DEFAULT AS IDENTITY,
    name VARCHAR(50) NOT NULL,
    CONSTRAINT c_reference_structure_level_pk PRIMARY KEY (reference_structure_level_s),
    CONSTRAINT c_reference_structure_level_name_unq UNIQUE (name),
    CONSTRAINT c_reference_structure_level_name_chk CHECK (name IN ('top', 'toc', 'detail'))
);

-- Эталонные структуры
CREATE TABLE reference_structure (
    reference_structure_s INTEGER GENERATED BY DEFAULT AS IDENTITY,
    information_resource_s INTEGER NOT NULL,
    reference_structure_level_s INTEGER NOT NULL,
    name VARCHAR(255) NOT NULL,
    description TEXT,
    CONSTRAINT c_reference_structure_pk PRIMARY KEY (reference_structure_s),
    CONSTRAINT c_reference_structure_info_res_fk FOREIGN KEY (information_resource_s) REFERENCES information_resource (information_resource_s) ON DELETE CASCADE,
    CONSTRAINT c_reference_structure_level_fk FOREIGN KEY (reference_structure_level_s) REFERENCES reference_structure_level (reference_structure_level_s),
    CONSTRAINT c_reference_structure_name_chk CHECK (length(trim(name)) > 0)
);

Передаю вторую часть модели данных:
-- Элементы эталонной структуры для каталогов
CREATE TABLE directory_design (
    directory_design_s INTEGER GENERATED BY DEFAULT AS IDENTITY,
    reference_structure_s INTEGER NOT NULL,
    parent_directory_design_s INTEGER,
    rule_type rule_type NOT NULL,
    dictionary_s INTEGER,
    literal_value VARCHAR(255),
    pattern_value VARCHAR(255),
    is_mandatory BOOLEAN NOT NULL DEFAULT false,
    is_unique BOOLEAN NOT NULL DEFAULT false,
    nesting_level INTEGER NOT NULL,
    is_date BOOLEAN NOT NULL DEFAULT false,
    date_sign CHAR(1),
    is_independent BOOLEAN NOT NULL DEFAULT true,
    CONSTRAINT c_directory_design_pk PRIMARY KEY (directory_design_s),
    CONSTRAINT c_directory_design_ref_struct_fk FOREIGN KEY (reference_structure_s) REFERENCES reference_structure (reference_structure_s) ON DELETE CASCADE,
    CONSTRAINT c_directory_design_parent_fk FOREIGN KEY (parent_directory_design_s) REFERENCES directory_design (directory_design_s),
    CONSTRAINT c_directory_design_dictionary_fk FOREIGN KEY (dictionary_s)    REFERENCES dictionary (dictionary_s));

ALTER TABLE directory_design ADD CONSTRAINT c_directory_design_date_chk CHECK (
        (is_date = false AND date_sign IS NULL) OR
        (is_date = true AND date_sign IN ('Y', 'M', 'D'))
);

ALTER TABLE directory_design ADD CONSTRAINT c_directory_design_pattern_date_chk CHECK (
        (is_date = false) OR
        (is_date = true AND rule_type = 'pattern')
);

ALTER TABLE directory_design ADD ​CONSTRAINT c_directory_design_rule_values_chk CHECK (
        (rule_type = 'literal' AND literal_value IS NOT NULL) OR
        (rule_type = 'dictionary' AND dictionary_s IS NOT NULL) OR
        (rule_type = 'pattern' AND pattern_value IS NOT NULL)
);

ALTER TABLE directory_design ADD CONSTRAINT c_directory_design_nesting_level_chk CHECK (nesting_level >= 0);


-- Элементы эталонной структуры для файлов
CREATE TABLE file_design (
    file_design_s INTEGER GENERATED BY DEFAULT AS IDENTITY,
    reference_structure_s INTEGER NOT NULL,
    parent_directory_design_s INTEGER,
    rule_type rule_type NOT NULL,
    dictionary_s INTEGER,
    literal_value VARCHAR(255),
    pattern_value VARCHAR(255),
    is_mandatory BOOLEAN NOT NULL DEFAULT false,
    is_unique BOOLEAN NOT NULL DEFAULT false,
    nesting_level INTEGER NOT NULL,
    CONSTRAINT c_file_design_pk PRIMARY KEY (file_design_s),
    CONSTRAINT c_file_design_ref_struct_fk FOREIGN KEY (reference_structure_s) REFERENCES reference_structure (reference_structure_s) ON DELETE CASCADE,
    CONSTRAINT c_file_design_parent_fk FOREIGN KEY (parent_directory_design_s) REFERENCES directory_design (directory_design_s),
    CONSTRAINT c_file_design_dictionary_fk FOREIGN KEY (dictionary_s) REFERENCES dictionary (dictionary_s));

ALTER TABLE file_design ADD CONSTRAINT c_file_design_rule_values_chk CHECK (
        (rule_type = 'literal' AND literal_value IS NOT NULL) OR
        (rule_type = 'dictionary' AND dictionary_s IS NOT NULL) OR
        (rule_type = 'pattern' AND pattern_value IS NOT NULL)
    );

ALTER TABLE file_design ADD CONSTRAINT c_file_design_nesting_level_chk CHECK (nesting_level >= 0);

-- Точки монтирования
CREATE TABLE mount_point (
    mount_point_s INTEGER GENERATED BY DEFAULT AS IDENTITY,
    toc_directory_design_s INTEGER NOT NULL,
    detail_reference_structure_s INTEGER NOT NULL,
    CONSTRAINT c_mount_point_pk PRIMARY KEY (mount_point_s),
    CONSTRAINT c_mount_point_toc_design_fk FOREIGN KEY (toc_directory_design_s) REFERENCES directory_design (directory_design_s),
    CONSTRAINT c_mount_point_detail_struct_fk FOREIGN KEY (detail_reference_structure_s) REFERENCES reference_structure (reference_structure_s),
    CONSTRAINT c_mount_point_toc_design_unq UNIQUE (toc_directory_design_s)
);

-- Таблица directory
CREATE TABLE directory (
    directory_s INTEGER GENERATED BY DEFAULT AS IDENTITY,
    information_resource_s INTEGER NOT NULL,
    parent_directory_s INTEGER,
    name VARCHAR(255) NOT NULL,
    relative_path VARCHAR(1024) NOT NULL,
    nesting_level INTEGER NOT NULL,
    first_discovered TIMESTAMP NOT NULL,
    owner VARCHAR(255),
    compliance_status compliance_status,
    compliance_message TEXT,
    is_actual BOOLEAN NOT NULL DEFAULT true,
    directory_design_s INTEGER,
    nsi_data_s INTEGER,
    CONSTRAINT c_directory_pk PRIMARY KEY (directory_s),
    CONSTRAINT c_directory_info_resource_fk FOREIGN KEY (information_resource_s) REFERENCES information_resource (information_resource_s) ON DELETE CASCADE,
    CONSTRAINT c_directory_parent_fk FOREIGN KEY (parent_directory_s) REFERENCES directory (directory_s),
    CONSTRAINT c_directory_design_fk FOREIGN KEY (directory_design_s) REFERENCES directory_design (directory_design_s),
    CONSTRAINT c_directory_nsi_data_fk FOREIGN KEY (nsi_data_s) REFERENCES nsi_data (nsi_data_s),
    CONSTRAINT c_directory_name_chk CHECK (length(trim(name)) > 0),
    CONSTRAINT c_directory_nesting_level_chk CHECK (nesting_level >= 0)
);
ALTER TABLE directory ADD CONSTRAINT c_directory_resource_path_unq
    UNIQUE (information_resource_s, relative_path);
-- Таблица file
CREATE TABLE file (
    file_s INTEGER GENERATED BY DEFAULT AS IDENTITY,
    directory_s INTEGER NOT NULL,
    information_resource_s INTEGER NOT NULL,
    name VARCHAR(255) NOT NULL,
    relative_path VARCHAR(1024) NOT NULL,
    nesting_level INTEGER NOT NULL,
    first_discovered TIMESTAMP NOT NULL,
    owner VARCHAR(255),
    creation_time TIMESTAMP,
    modification_time TIMESTAMP,
    last_access_time TIMESTAMP,
    size_bytes BIGINT,
    md5_hash VARCHAR(32),
    compliance_status compliance_status,
    compliance_message TEXT,
    is_actual BOOLEAN NOT NULL DEFAULT true,
    file_design_s INTEGER,
    hard_links INTEGER NOT NULL DEFAULT 1,
    CONSTRAINT c_file_pk PRIMARY KEY (file_s),
    CONSTRAINT c_file_directory_fk FOREIGN KEY (directory_s) REFERENCES directory (directory_s) ON DELETE CASCADE,
    CONSTRAINT c_file_info_resource_fk FOREIGN KEY (information_resource_s) REFERENCES information_resource (information_resource_s),
    CONSTRAINT c_file_design_fk FOREIGN KEY (file_design_s) REFERENCES file_design (file_design_s),
    CONSTRAINT c_file_name_chk CHECK (length(trim(name)) > 0),
    CONSTRAINT c_file_nesting_level_chk CHECK (nesting_level >= 0),
    CONSTRAINT c_file_size_chk CHECK (size_bytes >= 0),
    CONSTRAINT c_file_hard_links_chk CHECK (hard_links > 0),
    CONSTRAINT c_file_md5_chk CHECK (md5_hash ~ '^[a-f0-9]{32}$')
);
ALTER TABLE file ADD CONSTRAINT c_file_resource_path_unq
    UNIQUE (information_resource_s, relative_path);
ALTER TABLE file ADD COLUMN extension VARCHAR(10);
-- Индексы
CREATE INDEX idx_information_resource_data_domain ON information_resource(data_domain_s);
CREATE INDEX idx_directory_information_resource ON directory(information_resource_s);
CREATE INDEX idx_directory_parent ON directory(parent_directory_s);
CREATE INDEX idx_directory_design ON directory(directory_design_s);
CREATE INDEX idx_directory_nsi_data ON directory(nsi_data_s);
CREATE INDEX idx_file_directory ON file(directory_s);
CREATE INDEX idx_file_information_resource ON file(information_resource_s);
CREATE INDEX idx_file_design ON file(file_design_s);
CREATE INDEX idx_nsi_data_dictionary ON nsi_data(dictionary_s);
CREATE INDEX idx_nsi_data_x_data ON nsi_data_x(nsi_data_s);
CREATE INDEX idx_nsi_data_x_dependent ON nsi_data_x(dependent_on);

-- Частичные индексы
CREATE INDEX idx_directory_actual ON directory(directory_s) WHERE is_actual = true;
CREATE INDEX idx_file_actual ON file(file_s) WHERE is_actual = true;
CREATE INDEX idx_nsi_data_actual ON nsi_data(nsi_data_s) WHERE is_actual = true;
CREATE INDEX idx_dictionary_actual ON dictionary(dictionary_s) WHERE is_actual = true;
CREATE INDEX idx_directory_compliant ON directory(directory_s) WHERE compliance_status IN ('warning', 'compliant');
CREATE INDEX idx_file_compliant ON file(file_s) WHERE compliance_status IN ('warning', 'compliant');

